# APS응용_Start

[toc]

## SW 문제 해결

- SW 문제 해결 역량이란
  - 프로그램을 하기 위한 많은 제약 조건과 요구사항을 이해하고 최선의 방법을 찾아내는 능력
  - 라이브러리, 자료구조, 알고리즘에 대한 지식 등으로 큰 그림을 만드는 능력
  - 훈련이 필요
- 문제 해결 과정
  1. 문제를 읽고 이해한다
  2. 문제를 익숙한 용어로 재정의
  3. 어떻게 해결할지 계획을 세움
  4. 계획을 검증
  5. 프로그램으로 구현
  6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아봄
- 문제 해결 전략
  - 직관과 체계적인 접근



## 복잡도 분석

- 알고리즘 
  - 문제를 해결하기 위한 절차나 방법
- 알고리즘의 효율
  - 공간적 효율성 : 연산량 대비 얼마나 적은 메모리 공간을 요하는 가
  - 시간성 효율성 : 연산량 대비 얼마나 적은 시간을 요하는 가
  - 복잡도가 높을수록 효율성이 저하됨
  - 시간적 복잡도 분석
    - 하드웨어 환경에 따라 처리시간이 달라짐
      - 부동소수 처리 프로세서 존재유무
    - 소프트웨어 환경에 따라 처리시간이 달라짐
      - 프로그램 언어의 종류
      - 운영체제, 컴파일러의 종류
- 복잡도의 점근적 표기
  - 시간 (또는 공간) 복잡도는 입력 크기에 대한 함수로 표기 -> 주로 여러개의 항을 가지는 다항식



- O(Big-Oh)-표기
  - O-표기는 복잡도의 점근적 상한을 나타냄
  - 복잡도가 f(n) = 2*n^2 -7n + 4이라면 f(n)의 O-표기는 O(N^2)이다.
  - 최악의 경우를 표현



- Ω(Big-Omega)-표기
  - 복잡도의 점근적 하한
  - f(n) = 2n^2 - 7n + 4의 표기는 Ω(n^2)



- Θ(Theta)-표기
  - O-표기와 Ω-표기가 같은 경우에 사용



- 자주 사용하는 O-표기
  - O(1) : 항상 동일함
  - ...



- 왜 효율적인 알고리즘이 필요한가
  - 값비싼 H/W의 기술 개발보다 효율적인 알고리즘 개발이 훨씬 더 경제적이다.





## 표준 입출력 방법

- Python3 표준입출력

  - 입력
    - Raw 값의 입력: input()
      - 받은 입력값을 문자열을 취급
    - Evaluated된 값 입력 : eval(input())
      - 받은 입력값을 평가된 데이터 형으로 취급
  - 출력
    - print()
      - 표준 출력 함수. 출력값의 마지막에 개행 문자 포함
    - print('text, end='')
      - 출력 시, 마지막에 개행문자 제외할 시
    - print('%d' % number)
      - Formatting 된 출력

- 파일의 내용을 표준 입력으로 읽어오는 방법

  - import sys

  - sys.stdin = open("a.txt", "r")

    - stdin의 역할: 입력을 console에서 받아오던걸 파일에서 받아오게 하는 역할

    ```python
    import sys
    sys.stdin = open("input.txt", "r")
    sys.stdin = open("output.txt", "w")
    
    text = input()
    print(text)
    ```



## 비트 연산

- 비트 : 정보를 구분하는 최소 단위
- 바이트 : 메모리에서 위치를 구분하는 최소 단위

| 연산자 | 연산자의 기능                                                | 용도                                              |
| ------ | ------------------------------------------------------------ | ------------------------------------------------- |
| &      | 비트단위로 AND 연산<br />ex) num1 & num2                     | - 비트 검사<br />- 비트 클리어(특정 비트를 0으로) |
| \|     | 비트단위로 OR 연산<br />ex) num1 \| num2                     | - 비트 셋(특정 비트를 1로)                        |
| ^      | 비트단위로 XOR 연산(같으면 0 다르면 1)<br />ex) num1 ^ num2  | - 특정 비트가 같은지 검사<br />-비트 토글         |
| ~      | 단항 연산자로서 피연산자의 모든 비트를 반전시킴<br />ex) ~num |                                                   |
| <<     | 피연산자의 비트 열을 왼쪽으로 이동시킴<br />ex) num << 2 = num * 2^2 |                                                   |
| >>     | 피연산자의 비트 열을 오른쪽으로 이동시킴<br />ex) num >> 2   |                                                   |

- 비트 클리어
  - 010001에서 첫번째 1을 0으로 만들고 싶다면
  - 101111과 &
- 비트 토글
  - 반전시키고 싶은 비트를 1로 두면 반전됨
- `a |= 1 << 3` : a의 3번 비트를 1로 만들어라

- `a |= 1 << 1| 1 << 4` : a의 1번 비트와 4번 비트를 1로 만들어라
- `a &= ~(1<<3)` : a의 3번 비트 클리어
- `a &= ~(1<<3 | 1<<5)` : a의 b3, b5 클리어



- 1 << n
  - 2^n의 값을 가짐
  - 원소가 n개일 경우 모둔 부분집합의 수를 의미
  - Power set(모든 부분 집합)
    - 공집합과 자시 자신을 포함한 모든 부분집합
    - 각 원소가 포함되거나 포함되지 않는 2가지 경우의 수를 계산하면 모든 부분집합의수가 계산됨
- i & (1<<j)
  - i의 j번 비트를 검사
  - 계산 결과는 i의 j번째 비트가 1인지 아닌지를 의미



- 비트 연산 예제1

  ```python
  def Bbit_print(i):
      output = ""
      for j in range(7, -1, -1):
          output += "1" if i & (1 << j) else "0"
       print(output)
      
  for i in range(-5, 6):
      print("%3d = " % i, end='')
      Bbit_print(i)
  ```

  5 = 00000101

  -5 = 11111011 ( 00000101을 반전시키면 11111010임 -> 1더함 -> 11111011됨)



- 비트 연산 예제2

  ```python
  def Bbit_print(i):
      output = ""
      for j in range(7, -1, -1):
          output += "1" if i & (1 << j) else "0"
       print(output)
  a = 0x10						# 16진수 -> 16
  x = 0x01020304					# 
  print("%d = " % a, end='')
  Bbit_print(a)
  print()
  print("0%X = " % x, end='')
  for i in range(0, 4):
      Bbit_print((x >> i*8) & 0xff)
  ```

  

- 엔디안( Endianness)

  - 컴퓨터의 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법
    - HW 아키텍처마다 다름
  - 주의: 속도 향상을 위해 바이트 단위와 워드 단위를 변환하여 연산 할 때 올바로 이해하지 않으면 오류를 발생 시킬 수 있음
  - 빅 엔디안
    - 보통 큰 단위가 앞에 나옴. 네트워크
  - 리틀 엔디안
    - 작은 단위가 앞에 나옴. 대다수 데스크탑 컴퓨터

- 엔디안 확인 코드

  ```python
  import sys
  print(sys.byteorder)
  ```

  

- 비트 연산 예제3

  ```python
  def ce(n):			# change endian
      p = []
      for i in range(0, 4):
          p.append((n >> (24 - i*8)) & 0xff)
      return p
  ```

  ```python
  x = 0x01020304
  p = []
  for i in range(0, 4):
      p.append((x >> (i*8)) & 0xff)
      
  print("x = %d%d%d%d" % (p[0], p[1], p[2], p[3]))
  p = ce(x)
  print("x = %d%d%d%d" % (p[0], p[1], p[2], p[3]))
  ```



- 비트 연산 예제 4

  ```python
  def ce1(n):
      return (n << 24 & 0xff000000) | (n << 8 & 0xff0000) | (n >> 8 & 0xff00) | (n >> 24 & 0xff)
  ```



- 비트 연산 예제 5

  - 비트 연산자 ^를 두 번 연산하면 처음 값을 반환

  ```python
  def Bbit_print(i):
      output = ""
      for j in range(7, -1, -1):
          out += "1" if i & (1 << j) else "0"
  ....
  ```





## 진수

- 2진수, 8진수, 10진수, 16진수
- 10진수 -> 타 진수로 변환
  - 원하는 타진법의 수로 나눈 뒤 나머지를 거꾸로 읽는다
  - 149
    - 2진수 : 10010101
    - 8진수 : 225
    - 16진수 : 95

- 타 진수 -> 10진수로 변환
  - 135(8진수) = 1*8^2 + 3*8^1 + 5*8^0 = 93(10진수)
  - 소수점이 있을 때
    - -135.12(8진수) = 1*8^2 + 3*8^1 + 5*8^0  + 1*8^-1 + 2*8^-2 = -93.15625(10진수)
- 2진수, 8진수, 16진수간 변환
  - 2진법 - 8진법 : 3자리씩
  - 2진법 - 16진법 : 4자리씩



- 컴퓨터에서의 음의 정수 표현 방법
  - 1의 보수 : 부호와 절대값으로 표현된 값을 부호 비트를 제외한 나머지 비트들을 0은 1로, 1은 0으로 변환
    - -6 : 1의 보수 표현 ( 6을 반전시킴)
    - 단점 : +0과 -0이 다른 값이 됨
  - 2의 보수 : 1의 보수방법으로 표현된 값의 최하위 비트에 1을 더한다
    - 자리 하나 올려짐??????



```python
def ascii_to_hex(c):
    if c <= '9':
        return ord(c) - ord('0')
    else:
        return ord(C) = ord('A') + 10
    
def hex_to_binary(x):
    for i in range(4):
        t.append(asc[x][i])
        
t = []
arr = '0F97A3'
for i in range(len(arr)):
    hex_to_binary(ascii_to_hex(arr[i]))
```





## 실수

- 실수의 표현
  - 컴퓨터는 실수를 표현하기 위해 부동 소수점(floating-point) 표기법을 사용함
  - 부동 소수점 표기방법 : 소수점의 위치를 고정시켜 표현하는 방식
- 실수를 저장하기 위한 형식
  - IEEE754 :규격(?)
  - 단정도 실수(32비트)
  - 배정도 실수(64비트)
  - 가수부(mantissa) : 실수의 유효 자릿수들을 부호화된 고정 소수점으로 표현한 것
  - 지수부(exponent) : 실제 소수점의 위치를 지수 승으로 표현한 것
- 단정도 실수의 가수 부분을 만드는 방법
  - 1001.0011
  - 정수부의 첫 번째 자리가 1이 되도록 오른쪽으로 시프트
    - 0001.0010011
  - 소수점 이하를 23비트로 만든다
  - 소수점 이하만을 가수 부분에 저장
  - 지수 부분은 시프트 한 자릿수 만큼 증가 또는 감소
    -  
  - 지수부에는 8비트가 배정(256개의 상태를 나타낼 수 있음)
  - 숫자로는 0-255까지 나타낼 수 있지만, 음수 값을 나타낼 수 있어야 하므로 익세스(excess) 표현법 사용
    - 익세스 표현법 : 지수부의 값을 반으로 나누어 그 값을 0으로 간주하여 음수지수와 양수지수를 표현하는 방법

- 컴퓨터는 실수를 근사적으로 표현함

  ```python
  # 실수값이 서로 같은지 판별하려면
  if abs(a-b) < e:
  ```

  

- 실수 자료형의 유효 자릿수를 알아 두자

  - 32비트 실수형 유효자릿수(십진수) -> 6
  - 64비트 실수형 유효자릿수(십진수) -> 15

- 파이썬에서의 실수 표현 범위

  - 파이썬에서 내부적으로 더 많은 비트를 사용해서 훨씬 넓은 범위의 실수를 표현할 수 있음
  - 최대로 표현할 수 있는 값은 1.8 * 10^308, 그 이상은 inf
  - 최소로 표현할 수 있는 값은 약 5.0 * 10^(-324), 그 이하는 0





## 재귀

```pseudocode
f(i, N)
	if i == N
		return
	else
		f(i+1, N)
```

```pseudocode
# A 배열 B에 복사하기
f(i, N)
	if i == N
		return
	else
		B[i] <- A[i]
		f(i+1, N)
```

```python
def f(i, N):
    if i == N:
        return
    else:
        B[i] = A[i]
        f(i+1, N)

N = 3
A = [10, 20, 30]
B = [0] * N
f(0, N)
```

```python
# 결정된 리턴값을 이전 단계에 전달
def f(i, N, v):
    if i == N:		# 배열을 벗어난 경우 = 검색 실패
        return -1
    elif A[i] == v:
        return 1
    else:			# 배열을 벗어나지 않고 검색 실패한 경우
        return f(i+1, N, v)		# 리턴값을 다시 리턴

A = [7, 2, 5, 4, 1, 3]
N = len(A)
v = 5
print(f(0, N, v))	# 배열 A에 v가 있으면 1, 없으면 -1 리턴
```

```python
# 부분집합의 원소 포함 여부 출력(?)
def f(i, N):		# A[i]에 0 또는 i를 채우는 함수
    if i == N:		# A가 모두 채워진 경우
        print(A)
    else:
        for j in range(2):
            A[i] = j
            f(i+1, N)
        # A[i] = 0
        # f(i+1, N)
        # A[i] = 1
        # f(i+1, N)

N = 3
A = [0] * N
f(0, N)
```

```python
# A배열에 각각의 자리에 1/2/3 중에 하나 넣는 함수 - 중복순열
def f(i, N):
    if i == N:
        print(A)
    else:
        for j in range(1, 4):
            A[i] = j
            f(i+1, N)
    return


N = 3
A = [0] * N
f(0, N)
```

```python
# 1, 2, 3, 4, 5를 중복 사용해 3자리 수 만들기
def f(i, N, K):
    if i == N:
        print(A)
    else:
        for j in range(1, K+1):
            A[i] = j
            f(i+1, N, K)
    return

N = 3
K = 5
A = [0] * N
f(0, N, K)
```

```python
# 1~K를 중복사용 -> 3자리수 만들기 -> v값을 만들 수 있으면 중단하고 1리턴/없으면 0리턴
# 111 <= v
def f(i, N, K, v):
    if i == N:
        s = A[0]*100 + A[1]*10 + A[2]
        print(s)
        if s == v:
            return 1
        else:
            return 0
    else:
        for j in range(1, K+1):
            A[i] = j
            if f(i+1, N, K, v):
                return 1
        return 0
            

N = 3
K = 5
A = [0] * N
v = 123
f(0, N, K, v)
```

```python
# A의 부분집합의 합이 K인 부분집합의 개수 구하기
def f(i, N, s, K):		# s: i-1의 원소까지 고려된 부분집합의 합
    global cnt
    if i == N:
        if s == K:
            cnt += 1
    else:
        f(i+1, N, s+A[i], K)		# A[i]포함
        f(i+1, N, s, K)				# A[i] 포함하지 않음


A = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
N = len(A)
K = 30
cnt = 0
f(0, N, 0, K)
print(cnt)
```

