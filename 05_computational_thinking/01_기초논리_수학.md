# Computational Thinking

> 기초 논리 & 수학

[toc]

## 0. 서론 - 프로그래밍과 논리/수학

- 증명 : 정확하게 확인하는 과정을 수 많은 세월동안 정리해 둔 것

"어떤 전공도 상식선에서 이해되는 분야는 없다"

- 프로그래밍의 어려운 점 두 가지
  - 프로그래밍 언어 문법과 라이브러리 사용
  - 논리(Hard Logic)



- 논리(Hard Logic)
  - 카드 문제
    - 모든 카드의 한 쪽에는 알파벳이, 다른 쪽에는 숫자가 써 있음
    - 주장 : 만약 한쪽이 D이면 반대쪽은 3이다
    - 주장이 사실인지 확인하기 위해 다음 타드 중 반드시 뒤집어 보아야하는 것은 어는 것?
      - D / F / 3 / 7
  - 맥주집 문제
  - 카드 문제와 맥주집 문제는 완전히 같은 문제(논리적 구성 완전히 동일함)
  - 과자와 버스
    - '과자 몇 개 먹음?' vs. '버스 타려고 하는데 천원 있음?'
    - 전자 : 정확한 개수 요구 / 후자 : 천원 이상이 있는지 물어봄
  - 토플과 복권



- 일상 생활에서는
  - Soft Logic(직관)이 빠르기 때문에 유용
  - 논리적으로 부정확

- 프로그래밍은 Hard Logic을 사용
  - 프로그래밍 언어의 표현들이 모두 논리학에서 나온 것
  - 사용되는 수 많은 알고리즘들을 이해하기 위해서는 Hard Logic이 필요
- 오해의 근원
  - Soft Logic으로 알고리즘을 이해하려고 하는 것
  - 증명을 봐도 이해가 안 되는 것은 직관으로 이해하려고 하기 때문



**[참고]**

- 명제
  - 참이나 거짓을 알 수 있는 식이나 문장
  - p, q, r, ...로 표현
  - ex) 서울은 대한민국의 수도다
- 진리값
  - 참이나 거짓을 표현
  - T, F 또는 1, 0



[연산(결합)]

- 부정 NOT
  - p가 명제일 때, 명제의 진리값이 반대
  - ~p 또는 ￢p로 표기 (not p 또는 p의 부정으로 읽음)
- 논리곱 AND
  - p, q가 명제일 때, p, q 모두 참일 때만 참이 되는 명제
  - p ∧ q ( p and q)
- 논리합 OR
  - p, q가 명제일 때, p, q 모두 거짓일 때만 거짓이 되는 명제
  - p ∨ q (p or q)
- 배타적 논리합 XOR
  - p, q가 명제일 때, p, q 중 하나만 참일 때 참이 되는 명제
  - p ⊕ q (p xor q)



[합성]

- 연산자 우선 순위
  - not > ∨, ∨ > →, ↔
- 항진명제 : 진리값이 항상 참
- 모순명제 : 진리값이 항상 거짓
- 사건명제 : 항진명제도 모순명제도 아닌 명제



- 조건 명제
  - p, q가 명제일 때, 명제 p가 조건(또는 원인), q가 결론(또는 결과)로 제시되는 명제
  - q가 T이면 p와 상관없이 T
  - p가 F이면 q와 상관없이 T

- 쌍방조건명제
  - p, q가 명제일 때, 명제 p와 q가 모두 조건이면서 결론인 명제
  - p ↔ q (p이면 q고, q이면 p이다)
  - 양쪽이 다 참이거나, 양쪽이 다 거짓일 때만 T

- 조건명제의 역, 이, ★대우
  - 역 : q -> p
  - 이 : ~p -> ~q
  - 대우 : ~q -> ~p

- 논리 연습
  - 문제 1: 다음을 명제식 형태로 쓰고 참인지 거짓인지 판단하시오
    - 만약 0이 홀수라면, 미국에서 2080년 월드컵이 열린다.
      - 0이 홀수(F)이므로 T
    - 만약 198273454368092이 Prime Number라면, 2는 짝수이다.
      - 2가 짝수(T) 이므로 T

  - 문제 2 : p와 q가 명제이고 p -> q가 거짓이라고 하자. 다음 명제식의 참 거짓은 어떻게 되는가?
    1. ~p -> q (T)
    2. p ∨ q (T)
    3. q -> p (T)

  - 문제 3 : 다음 명제들의 역, 이, 대우를 쓰시오
    1. 만약 0이 홀수라면, 미국에서 2080년 월드컵이 열린다
    2. 만약 123095785762389421이Prime Number라면, 2는 짝수이다.

  - 문제 4 : 다음 명제식의 진리표를 만드시오
    1. p ∧ (q -> ~p)

       | p    | q    | ~p   | (q -> ~p) | p ∧ (q -> ~p) |
       | ---- | ---- | ---- | --------- | ------------- |
       | T    | T    | F    | F         | F             |
       | T    | F    | F    | T         | T             |
       | F    | T    | T    | T         | F             |
       | F    | F    | T    | T         | F             |

    1. (p ∧ ~p) -> r



- 증명
  - 증명은 정확한 명제식으로 표현할 수 있는 것이라야 함
  - 증명에 대한 수많은 오해가 p -> q를 p↔q와 혼동하는 것에서 일어남



- 수학적 귀납법과 증명의 수준
  - 수학적 귀납법의 기본형 : P(1)이 참이고, P(n) -> P(n+1)이 참이면 P(n)은 모든 자연수 n에 대해 참이다



- 증명 연습
  - Trivial Proof : ∀x(all x), P(x) -> Q(x)를 증명하려는데, Q(x)가 항상 참인 경우
  - 문제 1: 다음 명제를 증명하시오
    - 실수 x에 대해, 만약 x < -1이면 x^2 + 1/4 > 0이다
    - n이 홀수이면 4*n^3 + 6*n^2 + 12는 짝수이다
  - Vacuous Proof : ∀x(all x), P(x) -> Q(x)를 증명하려는데, P(x)가 항상 거짓인 경우
  - 문제 2: 다음 명제를 증명하시오
    - 실수 x에 대해, 만약 2*x^2 - 4*x + 4 < 0 이면 x > 8이다
    - 4*n^3 + 6*n^2 + 11이 짝수이면 n이 홀수이다





## 1. 논리와 증명

- 문제 1: 다음 명제들이 항진명제라는 것을 진리표를 이용해서 보이시오

  1. ~(~p ∧ q) ∨ q

     | p    | q    | ~p   | (~p ∧ q) | ~(~p ∧ q) | ~(~p ∧ q) ∨ q |
     | ---- | ---- | ---- | -------- | --------- | ------------- |
     | T    | T    |      |          |           |               |
     | T    | F    |      |          |           |               |
     | F    | T    |      |          |           |               |
     | F    | F    |      |          |           |               |

  2.  (~p ∨ q) ∨ (p ∧ ~q)

  

- 문제 2 : 다음 명제들이 모순명제라는 것을 진리표를 이용해서 보이시오.

  1. (~p ∨ q) ∧ ( p ∧ ~q)

     | p    | q    | ~p   | (~p ∨ q) | ~q   | ( p ∧ ~q) | (~p ∨ q) ∧ ( p ∧ ~q) |
     | ---- | ---- | ---- | -------- | ---- | --------- | -------------------- |
     | T    | T    | F    | T        | F    | F         | F                    |
     | T    | F    | F    | F        | T    | T         | F                    |
     | F    | T    | T    | T        | F    | F         | F                    |
     | F    | F    | T    | T        | T    | F         | F                    |

  2. (p ∧ q) ∧ (p ∧ ~q)

  

- 문제 3: 다음 명제의 쌍 들에 대해서 두 명제가 동등한지를 진리표를 이용해 확인하시오

  1. p ∧ (p ∨ q)와 p

     | p    | q    | (p ∨ q) | p ∧ (p ∨ q) |
     | ---- | ---- | ------- | ----------- |
     | T    | T    | T       | T           |
     | T    | F    | T       | T           |
     | F    | T    | T       | F           |
     | F    | F    | F       | F           |

  2. (p ∧ q) ∧ (p ∧ ~q)



- 문제 4 : 명제식의 변형을 통해 다음 명제를 간소화하시오
  1. (p ∧ ~q) ∨ (p ∧ q) = p ∧ (~q ∨ q) = p ∧ U = p
  2. (p ∨ ~q) ∧ (~p ∨ ~q)



- 문제 5: 다음 명제들이 참인지 확인하시오. 단, R은 실수의 집합을 의미하고, Z는 정수의 집합을 의미한다. (∀ = 모든, ∃ = 어떤)
  1. ∀x ∈ R, x^2 >= x (F - 반례 : x = 0.5)
  2. ∀x ∈ Z, x^2 >= x 
  3. ∃x ∈ R, x^2 < x 
  4. ∃x ∈ Z, x^2 < x 



- 문제 6: (직접 증명) n이 짝수이면 3*n + 5는 홀수임을 증명하라
  힌트 : n = 2k로 두고 3n + 5가 2(어떤 정수) + 1 형태로 표현될 수 있는지
  - 3 * 2k + 5 = 6k + 5 = 6k + 4 + 1 = 2(3k + 2) + 1



- 문제 7: n이 홀수이면 n^2 + n은 짝수임을 증명하라



- 문제 8: m이 짝수이고 n이 홀수이면 2m + 3n은 홀수임을 증명하라
  - m = 2k, n = 2h + 1
  - 2m + 3n = 4k + 6h + 3
  - 2(2k + 3h + 1) + 1 => 홀수



- 문제 9 : (대우를 증명) 자연수 n에 대해, n^2 + 5가 홀수이면 n은 짝수임을 증명하라
  (힌트: 명제 대신, n이 홀수이면 n^2 + 5는 짝수임을 증명한다)



- 문제 10 : n^2이 짝수이면 n은 짝수임을 증명하라
  - n = 2k -1
  - n^2 = 4k^2 - 4k + 1 => 홀수
  - 대우가 참이므로 명제는 참



- 문제 11: (경우를 나누어 증명) 자연수 n에 대해 n^2 + 5n + 3은 항상 홀수임을 증명하라
  (힌트 : n이 짝수인 경우와 홀수인 경우를 따로 증명한다)



- 문제 12 : n^2이 3의 배수이면 n은 3의 배수임을 증명하라



- 문제 1-2, 2-2, 3-2, 4-2, 5-2, 5-4, 7, 9, 11 직접 풀어볼 것



## 2. 수와 표현

- 컴퓨터는 0/1을 표현할 수 있는 비트들을 모아 수를 표현
- k개의 비트를 사용하면 0부터 2^k -1 까지 표현 가능
- 10진수로 k자리를 쓰면 0부터 10^k - 1까지 표현이 가능한 것과 완전히 동일한 과정
- 어떤 값 n을 표현하기 위해서는 몇 개의 비트가 필요할까?
  - 2^k - 1 >= n이 성립해야 함 => 2^k >= n + 1
  - k >= log(n+1) -> 약 logn 비트가 필요 (컴퓨터에서 쓰는 log는 log₂)
  - logn이란
    - 2의 몇 승이 n이 되느냐의 답
    - n을 표현하는 데 몇 비트가 필요한가의 답
    - 1로 시작해서 계속 두 배를 할 때 몇 번 하면 n이 되느냐의 답
    - n을 2로 계속 나눌 때 몇 번 나누면 거의 1이 되느냐에 대한 답
- x = logn일 때 x와 n을 비교하면 x가 더 작고, n이 커질수록 엄청나게 달라진다
  - 100자리로 표현할 수 있는 10진수 값은 읽을 수도 없을 정도로 큰 값이다
  - 컴퓨터 분야에서 로그의 밑은 항상 2
- 32비트 컴퓨터의 주소 공간은 2^23 = 약 40억개 주소



- 문제 1 : 2진수 표현에서 logn 비트로 표현할 수 있는 숫자 범위는?
  - log(2^n) = n -> n가지 (0 ~ (n-1))



- 문제 2: 스무고개가 이상적으로 진행된다고 할 때, 맞출 수 있는 답의 종류는 몇가지인가?



- 문제 3 : n이 충분히 큰 값일 때 다음 중 어느 값이 더 큰가? 각 쌍에 대해 비교하고 그 이유를 작성하시오.
  1. 2n  ( < )  n^2
  2. 2^(n/2)  ( < )  3^n^(1/2)
  3. 2^(nlogn)  ( > )  n!
     - 2^(nlogn) = n^n
  4. log2^(2n)  ( < )  n*n^(1/2)



- 문제 4:



- 문제 5 : 다음 함수들의 역함수를 구하시오
  1. f(x) = log(x-3) -5
     - y = 2^(x+5) + 3
  2. f(x) = 3log(x+3) + 1
  3. f(x) = 2*3^x -1



- 문제 2, 3-2, 3-4, 5-2 직접 풀어볼 것



## 3. 집합과 조합론

- 두 집합 A와 B에 대해 A가 B의 부분집합임을 증명ㅎ나다는 것은 A의 임의의 원소가 B에 포함됨을 보이는 것과 같다
  - 예를 들어, 모든 4의 배수는 2의 배수라는 것을 증명하려면, 4k = 2(2k)임을 보이면 됨
- 두 집합 A와 B가 같다는 것을 증명하기 위해서는 A가 B의 부분집합이고 B가 A의 부분집합임을 증명하면 됨



- 다음 두 집합이 같다는 것을 상세히 증명해보자.
  - A = {x|x=2k+1, k는 자연수}, B = {x|x=4k+1 혹은 x=4k+3, k는 자연수}
  - A가 B의 부분집합이다
    - A에 포함되는 임의의 원소 x를 가정
    - x = 2k+1
    - k가 짝수인 경우와 홀수인 경우로 나눔



- 조합론은 경우의 수를 따지는 문제들을 보통 말함
- 조합의 개수
  - nCr보다 괄호 표현을 더 많이 씀(n-위에 r-아래)



- 문제 1 : nCk + nC(k-1) = (n+1)Ck임을 증명하라



- 문제 4 : 귀류법을 이용하여 (A - B) ∩ (B - A) = ø

  - 귀류법 : 한 명제가 참인 것을 증명 => 명제의 부정을 참이라 가정 -> 모순이 되는 걸 증명함

  - p ∈ (A - B) 이고 p ∈ (B - A) 원소 p가 존재한다고 가정

    1. p ∈ A 이고 p not ∈ B -> 모순
    2. p not ∈ A 이고 p ∈ B -> 모순
    3. p not ∈ A 이고 p not ∈ B -> 모순
    4. p ∈ A 이고 p ∈ B -> 모순

    ∴ 참이다



- 문제  8 : 8 x 8 체스 판에 말 두개를 놓으려고 한다. 아무 곳에나 놓아도 되지만 한 칸에 두 개가 들어가지는 못한다. 가능한 방법은 모두 몇 가지 인가?



- 문제 10



- 문제 12 : 52개의 카드를 이요해서 만들 수 있는 5개 카드의 조합은 몇 가지 인가?
  - 52C5



- 문제 14 : x + y + z = 100의 자연수 해는 몇 가지 인가?



## 4. 기초 수식

- 알고리즘의 시간 복잡도를 표현할 수 있는 다양한 수식들이 존재한다
- 풀이법을 익혀 두어야 알고리즘의 시간 복잡도를 계산할 수 있고, 알고리즘이 시간이 얼마나 걸릴 지 예측할 수 있다



### 연습 문제들

> 다음 재귀식들을 O() notation 수준으로 풀어라

- 문제 1: T(n) = T(n-1) + 1, T(0) = 1
  - T(n) = T(n-1) + 1, T(0) = 1
  - T(n) = (T(n-2) + 1) + 1
  - T(n-k) + k
  - n = k인 경우 T(0) + n
  - 1 + n
  - O(n)



- 문제 2 : T(n) = T(n-1) + n, T(0) = 1



- 문제 3 : T(n) = T(n-1) + logn, T(0) = 1
  - = T(n-2) + log(n-1) + logn
  - = T(n-3) + log(n-2) + log(n-1) + logn
  - = T(n-k) + log(n-k+1) + ... + logn
  - = T(0) + log(1) + log(2) + ... + logn
  - <= T(0) + logn + logn + ... + logn
  - = T(0) + nlogn
  - O(nlogn)



- 문제 4 : T(n) = T(n/2) + 1, T(1) = 1
  - = (T(n/4) + 1) + 1
  - = (T(n/8) + 1) + 1+ 1
  - = T(n/(2^k)) + k
    - 2^k = n, k = logn
  - = T(1) + logn
  - = 1 + logn
  - O (logn)



- 문제 5 : T(n) = T(n/2) + n, T(1) = 1
  - = T(n/4) + n/2 + n
  - = T(n/(2^k)) + n/(2^k) + ... + n
  - = T(n/(2^k)) + n(1 + 1/2 + 1/4 + ... + 1/(2^(k-1)))
  - = T(1) + n(2)
  - 1 + 2n
  - O(n)



- 문제 6 : T(n) = 2T(n/2) + n, T(1) = 1



- 문제 7 : T(n) = 3T(n/2) + n, T(1) = 1
  - = 3(3T(n/4) + n/2) + n
  - = 3(3(3T(n/8) + n/4) + n/2) + n
  - = 3^k * T(n/(2^k)) + 3 ^ (k-1) * n / (2^(k-1)) + ... + 3 * n/2 + n
  - = 3^k * T(n/(2^k)) + ((3/2)^(k-1)*n + ... + 3/2) * n + n
  - = 3 ^ logn + 2n(3/2)^logn - 2n
  -  = n^log3 + 2n * n^log(3/2) - 2n
  -  = n^log3 + 2n * (n^log3 / n) - 2n
  - = 2*(n^log3) - 2n
  - O(n^log3)



- 문제 8 : T(n) = T(n-1) + (1/n), T(1) = 1



## 5. 재귀

- 재귀란 자기 자신을 호출하는 함수
- 함수는 입력이 있으며, 자기 자신의 입력과 동일한 입력으로 자기 자신을 호출하면 당연히 끝나지 않음
- 하지만, 다른 입력으로 호출하면 끝날 수 있음



- 함수란 어떤 문제를 해결하는 방법을 코딩한 것
- 함수가 어떤 문제의 단 한 케이스만을 해결하는 것이 아님
- 제대로 코딩 된 것이라면 해결하는 문제의 모든 케이스들을 해결해야 함



- 수학적 귀납법 증명 사용 가능



## 연습 문제들

> 다음 문제들을 푸는 재귀 알고리즘을 수도코드로 작성하고, 정확성 증명 및 시간 복잡도 계싼을 수행하라

- 문제 1 : 피보나치 수열 : F(n) = F(n-1) + F(n-2), F(1) = F(2) = 1

  ```pseudocode
  fibo(n){
  	if(n <= 2) return 1
  	return fibo(n-1) + fibo(n-2)
  }
  ```

  - T(n) = T(n-1) + T(n-2) + 1 <= 2T(n-1) + 1
  - 2T(n-1) + 1 = 2(2T(n-2)+ 1) + 1
  - = 2^k * T(n-k) + 2^(k-1) + ... + 1
  - = 2^nT(0) + 1 + 2 + ... + 2^(n-1)
  - O(2^n)



## 6. 동적 프로그래밍

- Memoization : 재귀 함수에서 동일한 입력의 함수 호출이 반복적으로 일어날 때 그 결과 값을 저장해 두고 불러 쓰는 것
- 최초 입력에서 파생되는 모든 가능한 입력에 대한 답을 모두 저장할 수 있는 메모리가 있어야 함
- 결과 값을 순서를 정해서 계산할 수 있다 (Dynamic Programming)



## 연습 문제들

- 문제 1 : Memoization 피보나치 수열

- 문제 2: Dynamic Programming 피보나치 수열
  (힌트 : 작은 값부터 순서대로 계산)

  
