## 01 데이터 타입

[toc]

### 01 데이터 타입의 종류

기본형 (primitive type)

- 숫자, 문자열, 불리언, null, undefined
- 심볼
- 불변성

참조형 (reference type)

- 객체, 배열, 함수, 날짜, 정규표현식
- Map, WeakMap, Set, WeakSet



### 02 데이터 타입에 관한 배경지식

#### 메모리와 데이터

비트

- 0 또는 1만 표현할 수 있는 하나의 메모리 조각

- 각 비트는 고유한 식별자를 통해 위치를 확인할 수 있음

바이트 

- 1 바이트 = 8 비트
- 1 바이트로 총 256개의 값을 표현할 수 있음

모든 데이터는 바이트 단위의 식별자(메모리 주솟값)을 통해 서로 구분하고 연결할 수 있음



#### 식별자와 변수

변수

- 변할 수 있는 데이터
- 변경 가능한 데이터가 담길 수 있는 공간 또는 그릇

식별자

- 어떤 데이터를 식별하는 데 사용하는 이름 => 변수명



### 03 변수 선언과 데이터 할당

#### 변수 선언

메모리에서 비어있는 공간 하나 확보

확보된 공간의 식별자를 변수명으로 지정



#### 데이터 할당

데이터 영역의 빈 공간에 값 저장

변수 영역에서 식별자 검색

앞서 저장한 값의 주소를 변수 선언 시 확보한 공간에 대입



### 04 기본형 데이터와 참조형 데이터

#### 불변값

기본형 데이터



#### 가변값

기본형 데이터와의 차이 : 객체의 변수(프로퍼티) 영역이 별도로 존재

데이터 영역은 기존의 메모리 공간을 그대로 활용

재할당

- 새로운 값으로 저장할 경우 기존 값이 저장된 주소를 참조하는 변수 사라짐
- 참조 카운트가 1이었다가 0으로 바뀜
- 참조 카운트가 0인 메모리 주소는 가비지 컬렉터(garbage collector, GC)의 수거 대상이 됨
  - GC는 런타임 환경에 따라 특정 시점이나 메모리 사용량이 포화상태에 임박할 때마다 자동으로 수거 대상들을 수거함
- 수거된 메모리는 다시 새로운 값을 할당할 수 있는 빈 공간이 됨



#### 변수 복사 비교

```javascript
var a = 10
var b = a
var obj1 = { c: 10, d: 'ddd' }
var obj2 = obj1

b = 15
obj2.c = 20
```

- 변수 a, b는 서로 다른 주소를 바라보게 됨
- 변수 obj1과 obj2는 여전히 같은 객체를 바라보고 있는 상태
- a !== b
- obj1 === obj2



자바스크립트의 모든 데이터 타입은 참조형 데이터

- 기본형은 주솟값을 복사하는 과정이 한 번만 이루어짐
- 참조형은 한 단계 더 거침



### 05 불변 객체

#### 불변 객체를 만드는 간단한 방법

불변 객체가 필요한 상황

- 값으로 전달받은 객체에 변경을 가하더라도 원본 객체는 변하지 않아야 하는 경우

  - 객체의 가변성에 따른 문제점

    ```javascript
    var user = {
        name: 'John',
        gender: 'male'
    }
    
    var changeName = function (user, newName) {
        var newUser = user
        newUser.name = newName
        return newUser
    }
    
    var user2 = changeName(user, 'Julia')
    
    if (user !== user2) {
        console.log('유저 정보가 변경되었습니다.')
    }
    console.log(user.name, user2.name)	// Julia Julia
    console.log(user === user2)			// true
    ```

  - 해결

    ```js
    var user = {
        name: 'John',
        gender: 'male'
    }
    
    var changeName = function (user, newName) {
        return {
            name: newName,
            gender: user.gender
        }
    }
    
    var user2 = changeName(user, 'Julia')
    
    if (user !== user2) {
        console.log('유저 정보가 변경되었습니다.')	// 유저 정보가 변경되었습니다.
    }
    console.log(user.name, user2.name)	// John Julia
    console.log(user === user2)			// false
    ```

    - 변경할 필요없는 기존 객체의 프로퍼티 gender를 하드코딩으로 입력함

  - 해결2 (얕은 복사)

    ```js
    var copyObject = function (target) {
        var result = {}
        for (var prop in target) {
            result[prop] = target[prop]
        }
        return result
    }
    ```

    - copyObject는 for in 문법을 이용해 result 객체에 target 객체의 프로터피들을 복사하는 함수
    
    ```js
    var user2 = copyObject(user)
    user2.name = 'Julia'
    ```
  



#### 얕은 복사와 깊은 복사

얕은 복사

- 바로 아래 단계의 값만 복사

- 원본을 바꾸면 사본도 바뀜

  ```js
  var user = {
      name: 'John',
      urls: {
          portfolio: 'http://github.com/John'
      }
  }
  var user2 = copyObject(user)
  
  user2.name = 'Julia'
  console.log(user.name === user2.name)	// false
  
  user.urls.portfolio = 'http://protfolio.com'
  console.log(user.urls.portfolio === user2.urls.portfolio)	// true
  ```

  

깊은 복사

- 내부의 모든 값을 하나하나 찾아서 전부 복사

- 객체의 프로퍼티 중 그 값이 참조형 데이터인 경우 다시 그 내부의 프로퍼티들을 복사해야 함

  ```js
  var copyObjectDeep = function(target) {
      var restul = {}
      if (typeof target === 'object' && target !== null) {
          for (var prop in target) {
              result[prop] = copyObjectDeep(target[prop])
          }
      } else {
          result = target
      }
      return result
  }
  ```

  - target이 객체인 경우 내부 프로퍼티들을 순회하며 copyObjectDeep 함수를 재귀적으로 호출
  - 객체가 아닌 경우에는 target을 그대로 지정
  - 어느 쪽의 프로퍼티를 변경하더라도 다른 쪽에 영향을 주지 않음



깊은 복사 2

> 객체를 JSON 문법으로 표현된 문자열로 전환했다가 다시 JSON 객체로 바꿈
>
> 단점 : 메서드(함수)나 숨겨진 프로퍼티인 `__proto__`나 getter/setter 등과 같이 JSON으로 변경할 수 없는 프로퍼티들은 모두 무시
>
> 순수한 정보만 다룰 때 활용하기 좋은 방법

```js
var copyObjectViaJSON = function (target) {
    return JSON.parse(JSON.stringify(target))
}
var obj = {
    a: 1,
    b: {
        c: null,
        d: [1, 2],
        func1: function () { console.log(3) }
    }
    func2: function () { console.log(4)}
}
var obj2 = copyObjectViaJSON(obj)

obj2.a = 3
obj2.b.c = 4
obj.b.d[1] = 3

console.log(obj)	// { a: 1, b: { c: null, d: [1, 3], func1: f() }, func2: f()}
console.log(obj2)	// { a: 3, b: { c: 4, d: [1, 2] } }
```

